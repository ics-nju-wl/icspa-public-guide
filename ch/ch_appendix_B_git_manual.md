# 附录B. Git入门教程

PA实验采用Git来管理项目代码，和SVN类似，Git是一个强大的版本控制工具。我们将代码托管在GitHub仓库，大家通过git clone命令就可以方便地获取框架代码。同时每次进行make的时候都会自动进行commit，方便我们追踪你的实验进程。
在平时的实验中，你也可以使用git来管理你的代码。Git带来的好处显而易见，你可以创建分支来进行试验性的内容，在通过测试后再合并到主分支。你也可以回滚对项目进行的改动，防止因为一时手残而带来的终身遗憾。网上有关git的资料和教程有很多，本教程只给出一点简单的入门信息，同时强调一点：
```
提交时只认master分支的代码！
```

相关资料推荐：
-	Git document（其中的GitHub Cheat Sheet很好用）：https://git-scm.com/doc
-	git - 简明指南：http://www.runoob.com/manual/git-guide/
-	man git, git help, 

## 简单Git入门

系统已配置好每个人的git仓库

### 查看存档信息

使用
> git log

查看目前为止所有的存档。

使用
> git status
可以得知与当前存档相比，哪些文件发生了变化。

### 存档

你可以像以前一样编写代码。等到你的开发取得了一些阶段性成果，你应该马上进行"存档"（当然在PA中，每次make都会自动帮你存档一次）。

首先你需要使用git status查看是否有新的文件或已修改的文件未被跟踪, 若有, 则使用git add将文件加入跟踪列表, 例如
> git add file.c

会将file.c加入跟踪列表。如果需要一次添加所有未被跟踪的文件，你可以使用
> git add . -A

但这样可能会跟踪了一些不必要的文件，例如编译产生的.o文件，和最后产生的可执行文件。事实上, 我们只需要跟踪代码源文件即可。为了让 git 在添加跟踪文件之前作筛选，你可以编辑 .gitignore 文件(你可以使用 ls -a 命令看到它),在里面给出需要被 git 忽略的文件和文件类型.

把新文件加入跟踪列表后, 使用 git status 再次确认. 确认无误后就可以存档了, 使用
> git commit

提交工程当前的状态. 执行这条命令后, 将会弹出文本编辑器, 你需要在第一行中添加本次存档的注释, 例如"fix bug for xxx". 你应该尽可能添加详细的注释, 将来你需要根据这些注释来区别不同的存档. 编写好注释之后, 保存并退出文本编辑器, 存档成功. 你可以使用` git log `查看存档记录, 你应该能看到刚才编辑的注释.

### 读档

如果你在进过了一些修改后发现自己犯下了严重的错误并希望回到过去的某个时间点，那么便可以使用读档功能来回到过去。首先使用 git log 来查看已有的存档, 并决定你需要回到哪个过去. 每一份存档都有一个hash code, 例如 b87c512d10348fd8f1e32ddea8ec95f87215aaa5 , 你需要通过hash code来告诉 git 你希望读哪一个档. 使用以下命令进行读档:
> git reset --hard b87c

其中 b87c 是上文hash code的前缀: 你不需要输入整个hash code. 这时你再看看你的代码, 你已经成功地回到了过去!

但事实上, 在使用 git reset 的hard模式之前, 你需要再三确认选择的存档是不是你的真正目标. 如果你读入了一个较早的存档, 那么比这个存档新的所有记录都将被删除! 这意为着你不能随便回到"将来"了.

### 分支

当然还是有办法来避免上文提到的副作用的, 这就是 git 的分支功能. 使用命令
> git branch

查看所有分支. 其中 master 是主分支, 使用 git init 初始化之后会自动建立主分支.
读档的时候使用以下命令
> git checkout b87c

而不是 git reset . 这时你将处于一个虚构的分支中, 你可以
-	查看 b87c 存档的内容
-	使用以下命令切换到其它分支
  > git checkout 分支名
  
-	对代码的内容进行修改, 但你不能使用 git commit 进行存档, 你需要使用
  > git checkout -B 分支名
  
  把修改结果保存到一个新的分支中, 如果分支已存在, 其内容将会被覆盖
  
不同的分支之间不会相互干扰，这也给项目的分布式开发带来了便利。有了分支功能，你就可以在一个分支的多个存档，或者是多个分支之间来回穿梭了。



